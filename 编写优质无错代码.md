# 第一章 假想地编译程序
* 使用编译程序所有的可选警告选项
* 用Lint来查出编译程序漏掉的错误
* 如果有单元测试，就进行单元测试

# 第二章 自己设计并使用断言
* 既要维护程序的交付版本，又要维护程序的调试版本
* 要使用断言对函数参数进行确认
* 要从程序中删除无定义的特性，或者在程序中使用断言来检查出无定义特性的非法使用
* 不要浪费别人的时间————详细说明不清楚的断言
* 消除所做的隐式假定，或者利用断言检查其正确性
* 利用断言来检查不可能发生的情况
* 在进行防错性程序设计时，不要隐瞒错误
* 要利用不同的算法对程序的结果进行确认
* 不要等待错误的发生，要使用初始检查程序

# 第三章 为子系统设防
* 要消除随机特性————使错误可再现
* 冲掉无用的信息，以免被错误地使用
* 如果某件事很少发生，设法让其经常发生
* 保存调试信息，以便进行更强地错误检查
* 建立详尽的子系统检查并且经常地进行这些检查
* 仔细设计程序的测试代码，任何选择都应该经过考虑
* 努力做到透明的一致性检查
* 不要把对交付版本的约束应用到相应的调试版本上，要用大小和速度来换取错误检查能力

# 第四章 对程序进行逐条跟踪
* 不要等到出了错误再对程序进行逐条地跟踪
* 对每一条代码路径进行逐条地跟踪
* 当对代码执行逐条跟踪时，要密切注视数据流
* 源级调试程序可能会隐瞒执行的细节，对关键部分的代码要进行汇编指令级的逐条跟踪

# 第五章 糖果机界面
* 要使用户不容易忽视错误情况，不要在正常地返回值中隐藏错误代码
* 要不遗余力地寻找并消除函数界面中的缺陷
* 不要编写多种功能集于一身的函数。为了对参数进行更强的确认，要编写功能单一的函数
* 不要模棱两可，要明确地定义函数的参数
* 编写函数使其在给定有效的输入情况下不会失败
* 使程序在调用点明了易懂；要避免布尔参数
* 编写注解突出可能的异常情况

# 第六章 风险事业
* 使用有严格定义的数据类型
* 经常反问：“这个变量表达式会上溢或下溢吗？”
* 尽可能精确地实现设计，近似地实现设计就可能出错
* 一个“任务”应一次完成
* 避免无关紧要的if语句
* 避免使用嵌套的“？：”运算符
* 每种特殊情况只能处理一次
* 避免使用有风险的语言惯用语
* 不能毫无必要地将不用类型地操作符混合使用，如果必须将不同类型地操作符混合使用，就用括号把它们隔离开来
* 避免调用返回错误的函数

# 第七章 编码中的假象
* 只引用属于你自己的存储空间
* 只有系统才能拥有空闲的存储区，程序员不能拥有
* 指向输出的指针不是指向工作空间缓冲区的指针
* 不要利用静态（或全局）量存储区传递数据
* 不要写寄生函数
* 不要滥用程序设计语言
* 紧凑的C代码并不能保证得到高效的机器代码
* 为一般水平的程序员编写代码

# 第8章 生下来的就是态度问题
* 错误几乎不会“消失”
* 马上修改错误，不要推迟到最后
* 修改错误要治本，不要治表
* 除非关系产品的成败，否则不要整理代码
* 不要实现没有战略意义的特征
* 不设自由特征
* 不允许没有必要的灵活性
* 在找到正确的解法之前，不要一味地“试”，要花时间寻求正确的解
* 尽量编写和测试小块代码。即使测试代码会影响进度，也要坚持测试代码
* 测试代码的责任不在测试员身上，而是程序员自己的责任
* 不要责怪测试员发现了你的错误
* 建立自己的优先级列表并坚持之

# 后记
* 决不允许同样的错误出现两次

# 附录 编码检查表
## 一般问题
* 你是否为程序建立了DEBUG 版本？
* 你是否将发现的错误及时改正了？
* 你是否坚持彻底测试代码．即使耽误了进度也在所不惜？
* 你是否依靠测试组为你测试代码？
* 你是否知道编码的优先顺序？
* 你的编译程序是否有可选的各种警告？

## 关于将更改合并到主程序
* 你是否将编译程序的警告（包括可选的）都处理了？
* 你的代码是否未用Lint
* 你的代码进行了单元测试吗？
* 你是否逐步通过了每一条编码路径以观察数据流？
* 你是否逐步通过了汇编语言层次上的所有关键代码？
* 是否清理过了任何代码？如果是，修改处经过彻底测试了吗？
* 文档是否指出了使用你的代码有危险之处？
* 程序维护人员是否能够理解你的代码？

## 每当实现了一个函数或子系统之时
* 是否用断言证实了函数参数的有效性？
* 代码中是否有未定义的或者无意义的代码？
* 代码能否创建未定义的数据？
* 有没有难以理解的断言？对它们作解释了没有？
* 你在代码中是否作过任何假设？
* 是否使用断言警告可能出现的非常情况？
* 是否作过防御性程序设计？代码是否隐藏了错误？
* 是否用第二个算法来验证第一个算法？
* 是否有可用于确认代码或数据的启动（startup）检查?
* 代码是否包含了随机行为？能消除这些行为吗？
* 你的代码若产生了无用信息，你是否在DEBUG 代码中也把它们置为无用信息？
* 代码中是否有稀奇古怪的行为？
* 若代码是子系统的一部分，那么你是否建立了一个子系统测试？
* 在你的设计和代码中是否有任意情况？
* 即使程序员不感到需要，你也作完整性检查吗？
* 你是否因为排错程序太大或太慢，而将有价值的DEBUG 测试抛置一边？
* 是否使用了不可移植的数据类型？
* 代码中是否有变量或表达式产生上溢或下溢？
* 是否准确地实现了你的设计？还是非常近似地实现了你的设计？
* 代码是否不止一次地解同一个问题？
* 是否企图消除代码中的每一个if 语句？
* 是否用过嵌套？：运算符？
* 是否已将专用代码孤立出来？
* 是否用到了有风险的语言惯用语？
* 是否不必要地将不同类型的运算符混用？
* 是否调用了返回错误的函数？你能消除这种调用吗？
* 是否引用了尚未分配的存储空间？
* 是否引用已经释放了的存储空间？
* 是否不必要地多用了输出缓冲存储？
* 是否向静态或全局缓冲区传送了数据？
* 你的函数是否依赖于另一个函数的内部细节？
* 是否使用了怪异的或有疑问的C 惯用语？
* 在代码中是否有挤在一行的毛病？
* 代码有不必要的灵活性吗？你能消除它们吗？
* 你的代码是经过多次“试着”求解的结果吗？
* 函数是否小并容易测试？

## 每当设计了一个函数或子系统后
* 此特征是否符合产品的市场策略？
* 错误代码是否作为正常返回值的特殊情况而隐藏起来？
* 是否评审了你的界面，它能保证难于出现误操作吗？
* 是否具有多用途且面面俱到的函数？
* 你是否有太灵活的（空空洞洞的）函数参数？
* 当你的函数不再需要时，它是否返回一个错误条件？
* 在调用点你的函数是出易读？
* 你的函数是否有布尔量输入？

## 修改错误之时
* 错误无法消失，是否能找到错误的根源？
* 是修改了错误的真正根源，还是仅仅修改了错误的症状？